\documentclass{article}

\usepackage{proof}
\usepackage{amsmath,amssymb,amsthm,textcomp}
\usepackage{fullpage}

\newtheorem{thm}{Theorem}

\usepackage{todonotes}

\newcommand{\var}{\mathbf{Var}}
\newcommand{\state}{\mathbf{State}}
\newcommand{\comm}{\mathbf{Comm}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\Aa}[2]{\mathcal{A}\left[#1\right]\left[#2\right]}
\newcommand{\N}{\mathcal{N}}
\newcommand{\true}{\mathbf{tt}}
\newcommand{\false}{\mathbf{ff}}
\newcommand{\expr}{\mathbf{exp}}
\newcommand{\Rule}[3]{\infer[\textsc{#1}]{#2}{#3}}
\newcommand{\Ref}{\mathrm{Ref}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Bool}{\mathrm{Bool}}

\newcommand{\ie}{\emph{i.e.}}


\title{Homework SOS}
\author{Aur\`ele Barri\`ere \& Florestan De Moor}
\date{November 4th 2018}

\begin{document}

\maketitle

\section*{Question 1}

%\textsc{Rule 1}\quad\infer{A}{B & C}

We define the $\state{}$ domain as follows:

\[
\state{} = \left(\var{}  \longrightarrow \mathbb{Z} \cup \mathbb{B} \right) \times \left( \mathbb{N} \longrightarrow \mathbb{Z} \right)
\]

\ie{} each variable is assigned to an integer or boolean  value, and each address of the memory (which is a natural) is mapped to an integer.

We then define our set of configurations:

\[
\C = \lbrace \left( c, (\sigma, \delta) \right) \mid c \in \comm{}, (\sigma, \delta) \in \state{} \rbrace \cup \C_{final}
\]

where $\C_{final} = \state{}$.

We define the denotational semantics of expressions $\A{}: \expr{} \longrightarrow \state{} \longrightarrow \mathbb{Z} \cup \mathbb{B}$ recursively as follows:

\begin{align*}
	\Aa{x}{\sigma, \delta} &= \sigma(x) \\
	\Aa{n}{\sigma, \delta} &= \N(n) \\
	\Aa{e_1 \circ e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \bullet \Aa{e_2}{\sigma, \delta} \\
	\Aa{\texttt{true}}{\sigma, \delta} &= \true{} \\
	\Aa{\texttt{false}}{\sigma, \delta} &= \false{} \\
	\Aa{\texttt{not}~e}{\sigma, \delta} &= \neg \Aa{e}{\sigma, \delta} \\
	\Aa{e1~\texttt{and}~e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \wedge \Aa{e_2}{\sigma, \delta} \\
	\Aa{e1~\texttt{or}~e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \vee \Aa{e_2}{\sigma, \delta} \\
	\Aa{[e]}{\sigma, \delta} &= \delta(\sigma(e)) \\
\end{align*}

where $\bullet \in \lbrace +, -, \times, =, \leq \rbrace$ is the semantic operator associated to the syntaxic operator $\circ$. $\A{}$ is a partial function. For instance, $\vee$ is defined as usual, only on boolean values.

We can now define a structural operational semantics of commands:

\[
	\Rule{Skip}{\texttt{skip}, \sigma, \delta \longrightarrow \sigma, \delta}{} \hspace*{1cm}
	\Rule{Seq1}{c_1 ; c_2, \sigma, \delta \longrightarrow c_2, \sigma', \delta'}{c_1, \sigma, \delta \longrightarrow \sigma', \delta'} \hspace*{1cm}
	\Rule{Seq2}{c_1 ; c_2, \sigma, \delta \longrightarrow c_1 ; c_2, \sigma', \delta'}{c_1, \sigma, \delta \longrightarrow c_1', \sigma', \delta'}
\]
\\
\[
	\Rule{AssignVar}{x := e, \sigma, \delta \longrightarrow \sigma[x \mapsto \Aa{e}{\sigma, \delta}], \delta}{x \in \var{}}
\]
\\
\[
	\Rule{AssignMem}{[e_1] := e_2, \sigma, \delta \longrightarrow \sigma, \delta[\Aa{e_1}{\sigma, \delta} \mapsto \Aa{e_2}{\sigma, \delta}]}{}
\]
\\
\[
	\Rule{If1}{\texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2, \sigma, \delta \longrightarrow c_1, \sigma, \delta}{} \quad \text{if $\Aa{e}{\sigma, \delta} = \true{}$}
\]
\\
\[
	\Rule{If2}{\texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2, \sigma, \delta \longrightarrow c_2, \sigma, \delta}{} \quad \text{if $\Aa{e}{\sigma, \delta} = \false{}$}
\]
\\
\[
	\Rule{While}{\texttt{while}~e~\texttt{do}~c, \sigma, \delta \longrightarrow \texttt{if}~e~\texttt{then}~(c; \texttt{while}~e~\texttt{do}~c)~\texttt{else}~\texttt{skip}, \sigma, \delta}{} 
\]

\paragraph{Comments}
We define our $\state$ domain as a cartesian product for readability, the second function only describing the memory.
Final configurations are simply states, with no more commands to execute.

As expressions define both booleans and integer expressions, our $\A{}$ function can be evaluated in $\mathbb{Z}$ or $\mathbb{B}$.

Our semantics is defined such that some programs may not evaluate to a final configuration. We give below a few examples:

\texttt{[-3] := 0} will not evaluate, because for any state $(\sigma,\delta)$, $\delta$ is only defined on $\mathbb{N}$. Thus the \textsc{AssignMem} rule can't be applied.

\texttt{x := true + 2} won't make any progress, because $\Aa{true + 2}{\sigma,\delta}$ isn't defined for any $(\delta,\sigma)$.

\texttt{if 1 then c\_1 else c\_2} won't make any progress, because $\Aa{1}{\sigma,\delta}$ is neither equal to \textbf{tt} nor \textbf{ff}.

Another solution could be to allow such programs to progress to an error final configuration, displaying an adequate error message.

Our structural operational semantics is partial and deterministic.

\section*{Question 2}

We now introduce three different types in our system:

\begin{itemize}
	\itemsep0em
	\item[--] $\Int{}$: denotes integer values
	\item[--] $\Ref{}$: denotes references \ie{} memory addresses
	\item[--] $\Bool{}$: denotes boolean values (that evaluates to true or false)
\end{itemize}

We define the following typing rules for expressions, given a context $\Gamma$:

\[
\Rule{CstInt}{\Gamma \vdash n: \Int}{}
\hspace*{1cm}
\Rule{CstRef}{\Gamma \vdash n: \Ref}{} \quad \text{if $\N(n) \geq 0$}
\]

\[
\Rule{CstTrue}{\Gamma \vdash \texttt{true}: \Bool}{}
\hspace*{1cm}
\Rule{CstFalse}{\Gamma \vdash \texttt{false}: \Bool}{}
\]

\[
\Rule{Var}{\Gamma \vdash x: T}{\lbrace x: T \rbrace \in \Gamma}
\hspace*{1cm}
\Rule{CastRefToInt}{\Gamma \vdash x: \Int}{\Gamma \vdash x: \Ref}
\]

\[
\Rule{AddInt}{\Gamma \vdash e_1 + e_2: \Int}{\Gamma \vdash e_1: \Int \quad \Gamma \vdash e_2: \Int}
\hspace*{1cm}
\Rule{AddRef}{\Gamma \vdash e_1 + e_2: \Ref}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Ref}
\]

\[
\Rule{SubInt}{\Gamma \vdash e_1 - e_2: \Int}{\Gamma \vdash e_1: \Int \quad \Gamma \vdash e_2: \Int}
\hspace*{1cm}
\Rule{SubRef}{\Gamma \vdash e_1 - e_2: \Ref}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Ref}
\]

\[
\Rule{TimesInt}{\Gamma \vdash e_1 \times e_2: \Int}{\Gamma \vdash e_1: \Int \quad \Gamma \vdash e_2: \Int}
\hspace*{1cm}
\Rule{TimesRef}{\Gamma \vdash e_1 \times e_2: \Ref}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Ref}
\]

\[
\Rule{EqInt}{\Gamma \vdash e_1 = e_2: \Bool}{\Gamma \vdash e_1: \Int \quad \Gamma \vdash e_2: \Int}
\hspace*{1cm}
\Rule{EqRef}{\Gamma \vdash e_1 = e_2: \Bool}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Ref}
\]

\[
\Rule{CompInt}{\Gamma \vdash e_1 \leq e_2: \Bool}{\Gamma \vdash e_1: \Int \quad \Gamma \vdash e_2: \Int}
\hspace*{1cm}
\Rule{CompRef}{\Gamma \vdash e_1 \leq e_2: \Bool}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Ref}
\]

\[
\Rule{And}{\Gamma \vdash e_1~\texttt{and}~e_2: \Bool}{\Gamma \vdash e_1: \Bool \quad \Gamma \vdash e_2: \Bool}
\hspace*{1cm}
\Rule{Or}{\Gamma \vdash e_1~\texttt{or}~e_2: \Bool}{\Gamma \vdash e_1: \Bool \quad \Gamma \vdash e_2: \Bool}
\hspace*{1cm}
\Rule{Not}{\Gamma \vdash \texttt{not}~e: \Bool}{\Gamma \vdash e: \Bool}
\]

We can now give the type judgment for each command in the typing context $\Gamma$:

\[
	\Rule{Skip}{\Gamma \vdash \texttt{skip}}{} \hspace*{1cm}
	\Rule{Seq}{\Gamma \vdash c_1 ; c_2}{\Gamma \vdash c_1 \quad \Gamma \vdash c_2}
\]
\[
	\Rule{AssignVar}{\Gamma \vdash x := e}{\Gamma \vdash x: T \quad \Gamma \vdash e: T} \hspace*{1cm}
	\Rule{AssignMem}{\Gamma \vdash [e_1] := e_2}{\Gamma \vdash e_1: \Ref \quad \Gamma \vdash e_2: \Int}
\]
\[
	\Rule{If}{\Gamma \vdash \texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2}{\Gamma \vdash e: \Bool \quad \Gamma \vdash c_1 \quad \Gamma \vdash c_2}
\hspace*{1cm}
	\Rule{While}{\Gamma \vdash \texttt{while}~e~\texttt{do}~c}{\Gamma \vdash e: \Bool \quad \Gamma \vdash c} 
\]


\paragraph{Comments}

A program $c$ is said to be well-typed if there exists some context $\Gamma$ such that $\Gamma\vdash c$.
A typing context is a set of pairs of variables and types $\{x:T\}$, meaning that variable $x$ has type $T$, and such that each $x$ appears at most once.
There are simple ways to find statically such a typing context whenever it exists. One ambiguity appears when dealing with variables defined with positive constants, as they could be both $\Int$ or $\Ref$. In that case, type them $\Ref$, and you may use the \textsc{CastRefToInt} rule whenever you need an $\Int$.
Some programs can be well-typed under several contexts, for instance \texttt{x := y} where the variables can be Integers, Booleans or References.

Our typing system prevents negative constants to be used as references.
This rules out a few programs that could have blocking semantics.
Our reference arithmetic still allows multiplication, addition and subtraction, meaning that some well-typed programs can still go wrong.
A solution to this issue is to forbid subtraction when dealing with references, but we decided against to keep ``reasonable'' pointer arithmetic.

Some programs with non-blocking semantics won't be well-typed when it corresponds to what we consider to be programming mistakes. For instance, \texttt{x := 1; x := true} progresses with our semantics but isn't well-typed.

The expression typing rules are as expected, and we can't mix boolean values with integers values for instance. Thus, the program \texttt{x := 1 + true} won't be well-typed. A good property of our type system is the following:\\

\paragraph{Definition} $\sigma$ is said to be \textit{well-defined with regards to} $\Gamma$, if for all $\{x:Int\}\in\Gamma$, $\sigma(x)\in\mathbb{Z}$, for all $\{x:Ref\}\in\Gamma$, $\sigma(x)\in\mathbb{N}$ and for all $\{x:Bool\}\in\Gamma$, $\sigma(x)\in\mathbb{B}$.

\paragraph{Definition} We define $\vdash'$, exactly the same as $\vdash$ but without the \textsc{SubRef} rule.

\begin{thm}[Typing of Expressions]
For all expression $e$, context $\Gamma$, type $T$ and state $(\sigma, \delta)$ and $\sigma$ well-defined with regards to $\Gamma$, we have:
\[
\Gamma\vdash' e : T\implies \Aa{e}{\sigma,\delta}\text{ is defined}.
\]
\end{thm}

\begin{proof}
\todo{todo, induction}
\end{proof}


\begin{thm}[Progress]
For all program $c$, context $\Gamma$ and initial state $(\sigma_0, \delta_0) \in \state{}$ such that $\sigma_0$ well-defined with regards to $\Gamma$, we have:
\[
\Gamma \vdash' c \implies \exists (\sigma, \delta) \in \state{} \quad c, \sigma_0, \delta_0 \longrightarrow \sigma, \delta
\]
\end{thm}

\begin{proof}
\todo{todo, induction + theorem expression typing}
not true if Ref subtraction?
\end{proof}

TODO: commentaire de conclusion.


\section*{Question 3}


\end{document}
