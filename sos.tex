\documentclass{article}

\usepackage{proof}
\usepackage{amsmath,amssymb,amsthm,textcomp}
\usepackage{fullpage}

\newcommand{\var}{\mathbf{Var}}
\newcommand{\state}{\mathbf{State}}
\newcommand{\comm}{\mathbf{Comm}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\Aa}[2]{\mathcal{A}\left[#1\right]\left[#2\right]}
\newcommand{\N}{\mathcal{N}}
\newcommand{\true}{\mathbf{tt}}
\newcommand{\false}{\mathbf{ff}}
\newcommand{\expr}{\mathbf{exp}}
\newcommand{\Rule}[3]{\infer[\textsc{#1}]{#2}{#3}}
\newcommand{\Ref}{\mathrm{Ref}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Bool}{\mathrm{Bool}}

\newcommand{\ie}{\emph{i.e.}}


\title{Homework SOS}
\author{Aur\`ele Barri\`ere \& Florestan De Moor}
\date{November 4th 2018}

\begin{document}

\maketitle

\section*{Question 1}

%\textsc{Rule 1}\quad\infer{A}{B & C}

We define the $\state{}$ domain as follows:

\[
\state{} = \left(\var{}  \longrightarrow \mathbb{Z} \right) \times \left( \mathbb{N} \longrightarrow \mathbb{Z} \right)
\]

\ie{} each variable is assigned to an integer value, and each address of the memory (which is a natural) is mapped to an integer.

We then define our set of configurations:

\[
\Gamma = \lbrace \left( c, (\sigma, \delta) \right) \mid c \in \comm{}, (\sigma, \delta) \in \state{} \rbrace \cup \Gamma_{final}
\]

where $\Gamma_{final} = \state{}$.

We define the denotational semantics of expressions $\A{}: \expr{} \longrightarrow \state{} \longrightarrow \mathbb{Z} \cup \mathbb{B}$ recursively as follows:

\begin{align*}
	\Aa{x}{\sigma, \delta} &= \sigma(x) \\
	\Aa{n}{\sigma, \delta} &= \N(n) \\
	\Aa{e_1 \circ e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \bullet \Aa{e_2}{\sigma, \delta} \\
	\Aa{\texttt{true}}{\sigma, \delta} &= \true{} \\
	\Aa{\texttt{false}}{\sigma, \delta} &= \false{} \\
	\Aa{\texttt{not}~e}{\sigma, \delta} &= \neg \Aa{e}{\sigma, \delta} \\
	\Aa{e1~\texttt{and}~e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \wedge \Aa{e_2}{\sigma, \delta} \\
	\Aa{e1~\texttt{or}~e_2}{\sigma, \delta} &= \Aa{e_1}{\sigma, \delta} \vee \Aa{e_2}{\sigma, \delta} \\
	\Aa{[e]}{\sigma, \delta} &= \delta(\sigma(e)) \\
\end{align*}

where $\bullet \in \lbrace +, -, \times, =, \leq \rbrace$ is the semantic operator associated to the syntaxic operator $\circ$. $\A{}$ is a partial function. For instance, $\vee$ is defined as usual, only on boolean values.

We can now define a structural operational semantics of commands:

\[
	\Rule{Skip}{\texttt{skip}, \sigma, \delta \longrightarrow \sigma, \delta}{} \hspace*{1cm}
	\Rule{Seq1}{c_1 ; c_2, \sigma, \delta \longrightarrow c_2, \sigma', \delta'}{c_1, \sigma, \delta \longrightarrow \sigma', \delta'} \hspace*{1cm}
	\Rule{Seq2}{c_1 ; c_2, \sigma, \delta \longrightarrow c_1 ; c_2, \sigma', \delta'}{c_1, \sigma, \delta \longrightarrow c_1', \sigma', \delta'}
\]
\[
	\Rule{AssignVar}{x := e, \sigma, \delta \longrightarrow \sigma[x \mapsto \Aa{e}{\sigma, \delta}], \delta}{x \in \var{}} \hspace*{1cm}
	\Rule{AssignMem}{[e_1] := e_2, \sigma, \delta \longrightarrow \sigma, \delta[\Aa{e_1}{\sigma, \delta} \mapsto \Aa{e_2}{\sigma, \delta}]}{}
\]
\[
	\Rule{If1}{\texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2, \sigma, \delta \longrightarrow c_1, \sigma, \delta}{} \quad \text{if $\Aa{e}{\sigma, \delta} = \true{}$}
\]
\[
	\Rule{If2}{\texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2, \sigma, \delta \longrightarrow c_2, \sigma, \delta}{} \quad \text{if $\Aa{e}{\sigma, \delta} = \false{}$}
\]
\[
	\Rule{While}{\texttt{while}~e~\texttt{do}~c, \sigma, \delta \longrightarrow \texttt{if}~e~\texttt{then}~(c; \texttt{while}~e~\texttt{do}~c)~\texttt{else}~\texttt{skip}, \sigma, \delta}{} 
\]

\paragraph{Comments}
We define our $\state$ domain as a cartesian product for readability, the second function only describing the memory.
Final configurations are simply states, with no more commands to execute.

As expressions define both booleans and integer expressions, our $\A{}$ function can be evaluated in $\mathbb{Z}$ or $\mathbb{B}$.

Our semantics is defined such that some programs may not evaluate to a final configuration. We give below a few examples:

\texttt{[-3] := 0} will not evaluate, because for any state $(\sigma,\delta)$, $\delta$ is only defined on $\mathbb{N}$. Thus the \textsc{AssignMem} rule can't be applied.

\texttt{x := true + 2} won't make any progress, because $\Aa{true + 2}{\sigma,\delta}$ isn't defined for any $(\delta,\sigma)$.

\texttt{if 1 then c\_1 else c\_2} won't make any progress, because $\Aa{1}{\sigma,\delta}$ is neither equal to \textbf{tt} nor \textbf{ff}.

Another solution could be to allow such programs to progress to an error final configuration, displaying an adequate error message.

Our structural operational semantics is partial and deterministic.

\section*{Question 2}

We now introduce three different types in our system:

\begin{itemize}
	\itemsep0em
	\item[--] $\Int{}$: denotes integer values
	\item[--] $\Ref{}$: denotes references \ie{} memory addresses
	\item[--] $\Bool{}$: denotes boolean values (that evaluate to true or false)
\end{itemize}

We define the following typing rules for expressions, given a context $A$:

\[
\Rule{CstInt}{A \vdash n: \Int}{}
\hspace*{1cm}
\Rule{CstRef}{A \vdash n: \Ref}{} \quad \text{if $\N(n) \geq 0$}
\]

\[
\Rule{CstTrue}{A \vdash \texttt{true}: \Bool}{}
\hspace*{1cm}
\Rule{CstFalse}{A \vdash \texttt{false}: \Bool}{}
\]

\[
\Rule{Var}{A \vdash x: T}{\lbrace x: T \rbrace \in A}
\hspace*{1cm}
\Rule{CastRefToInt}{A \vdash x: \Int}{A \vdash x: \Ref}
\]

\[
\Rule{AddInt}{A \vdash e_1 + e_2: \Int}{A \vdash e_1: \Int \quad A \vdash e_2: \Int}
\hspace*{1cm}
\Rule{AddRef}{A \vdash e_1 + e_2: \Ref}{A \vdash e_1: \Ref \quad A \vdash e_2: \Ref}
\]

\[
\Rule{SubInt}{A \vdash e_1 - e_2: \Int}{A \vdash e_1: \Int \quad A \vdash e_2: \Int}
\hspace*{1cm}
\Rule{SubRef}{A \vdash e_1 - e_2: \Ref}{A \vdash e_1: \Ref \quad A \vdash e_2: \Ref}
\]

\[
\Rule{TimesInt}{A \vdash e_1 \times e_2: \Int}{A \vdash e_1: \Int \quad A \vdash e_2: \Int}
\hspace*{1cm}
\Rule{TimesRef}{A \vdash e_1 \times e_2: \Ref}{A \vdash e_1: \Ref \quad A \vdash e_2: \Ref}
\]

\[
\Rule{EqInt}{A \vdash e_1 = e_2: \Bool}{A \vdash e_1: \Int \quad A \vdash e_2: \Int}
\hspace*{1cm}
\Rule{EqRef}{A \vdash e_1 = e_2: \Bool}{A \vdash e_1: \Ref \quad A \vdash e_2: \Ref}
\]

\[
\Rule{CompInt}{A \vdash e_1 \leq e_2: \Bool}{A \vdash e_1: \Int \quad A \vdash e_2: \Int}
\hspace*{1cm}
\Rule{CompRef}{A \vdash e_1 \leq e_2: \Bool}{A \vdash e_1: \Ref \quad A \vdash e_2: \Ref}
\]

\[
\Rule{And}{A \vdash e_1~\texttt{and}~e_2: \Bool}{A \vdash e_1: \Bool \quad A \vdash e_2: \Bool}
\hspace*{1cm}
\Rule{Or}{A \vdash e_1~\texttt{or}~e_2: \Bool}{A \vdash e_1: \Bool \quad A \vdash e_2: \Bool}
\hspace*{1cm}
\Rule{Not}{A \vdash \texttt{not}~e: \Bool}{A \vdash e: \Bool}
\]

We can now give the type judgment for each command in the typing context $A$:

\[
	\Rule{Skip}{A \vdash \texttt{skip}}{} \hspace*{1cm}
	\Rule{Seq}{A \vdash c_1 ; c_2}{A \vdash c_1 \quad A \vdash c_2}
\]
\[
	\Rule{AssignVar}{A \vdash x := e}{A \vdash x: T \quad A \vdash e: T} \hspace*{1cm}
	\Rule{AssignMem}{A \vdash [e_1] := e_2}{A \vdash e_1: \Ref \quad A \vdash e_2: \Int}
\]
\[
	\Rule{If}{A \vdash \texttt{if}~e~\texttt{then}~c_1~\texttt{else}~c_2}{A \vdash e: \Bool \quad A \vdash c_1 \quad A \vdash c_2}
\hspace*{1cm}
	\Rule{While}{A \vdash \texttt{while}~e~\texttt{do}~c}{A \vdash e: \Bool \quad A \vdash c} 
\]


\paragraph{Comments}

A program $c$ is said to be well-typed if there exists some context $A$ such that $A\vdash c$.
A typing context is a set of pairs of variables and types $\{x:T\}$, meaning that variable $x$ has type $T$, and such that each $x$ appears at most once.
There are simple ways to find statically such a typing context whenever it exists: start with an empty context and add new pairs as you look through the program. The only ambiguity appears when dealing with variables defined with positive constants, as they could be both $\Int$ or $\Ref$. In that case, type them $\Ref$, and you may use the \textsc{CastRefToInt} rule whenever you need an $\Int$.

Our typing system prevents negative constants to be used as references.
This rules out a few programs that could have blocking semantics.
Our reference arithmetic still allows multiplication, addition and substraction, meaning that some well-typed programs can still go wrong.
A solution to this issue is to forbid substraction when dealing with references, but we decided against to keep ``reasonable'' pointer arithmetics.

The expression typing rules are as expected, and we can't mix boolean values with integers values for instance. Thus, the program \texttt{x := 1 + true} won't be well-typed. A good property of our type system is the following:\\

$\forall e\text{ expression without memory access}, \forall A\text{ context}, \forall T\text { type}, \forall \delta, \forall \sigma \text{ defined on all variables of e},$
$$A\vdash e : T\implies \Aa{e}{\sigma,\delta}\text{ is defined}.$$


TODO: change le nom du contexte de A à gamma pour ne pas confondre avec la fonction sémantique. Preuve de la propriété de typage. Ajouter une propriété sur la progression d'un programme (pas seulement pour les expressions).

\section*{Question 3}


\end{document}
